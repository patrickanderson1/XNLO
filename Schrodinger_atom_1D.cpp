//
//  Schrodinger_atom_1D.hpp
//
//  Modified by Patrick Anderson on 07/05/2015.
//  "Schrodinger_atom_1D" encapsulates the interaction of an isolated atom with a strong laser
//  field. The interaction is restricted to a single active electron and spatial dimension. Atomic
//  units.
//

#include "Schrodinger_atom_1D.hpp"
#include "maths_textbook.hpp"
#include "physics_textbook.hpp"
#include "grid_xkx.hpp"
#include <Eigen/Dense>
#include <mkl.h>

using namespace Eigen;

//------------------------------------------------------------------------------------------------//
//  Class implementation
//------------------------------------------------------------------------------------------------//
//  Constructor

Schrodinger_atom_1D::Schrodinger_atom_1D(double alpha_) {
    
    maths_textbook maths;
    physics_textbook physics;
    grid_xkx temp(std::pow(2.0, 12), -300, 300);
    xkx = temp;
    
    // Model potential (Soft Coulomb)
    alpha = alpha_;
    V_model = -1 / (alpha + xkx.x.pow(2)).sqrt();
    
    // Ground state wavefunction
    Schrodinger_atom_1D::set_GS(1000);
    
}

//------------------------------------------------------------------------------------------------//
// Find the GS wavefunction by imaginary time propagation, display energy

void Schrodinger_atom_1D::set_GS(int N_it_) {

    maths_textbook maths;
    
    // Create an imaginary time step and zero field
    std::complex<double> dt(0.0, -0.01);
    ArrayXd E = ArrayXd::Zero(N_it_);
    
    // Seed
    double FWHM = 30;
    double k = 1 / (2 * std::pow(FWHM / 2.35, 2));
    wfn_GS = (-k * xkx.x.pow(2)).exp().cast<std::complex<double> >();
    wfn_GS *= std::pow(maths.trapz(xkx.x, wfn_GS.abs2()), -0.5);

    // Solve TDSE
    ArrayXd temp = Schrodinger_atom_1D::solve_TDSE_PS(N_it_, dt, E, 0);
    wfn_GS = wfn;
    std::cout << "Energy: "<< energy * 27.211 << " eV" << std::endl;

}

//------------------------------------------------------------------------------------------------//
// Find the dipole moment generated by an arbitary field

ArrayXd Schrodinger_atom_1D::get_dipole(int N_it_, double dt_, ArrayXd E_) {
    
    physics_textbook physics;
    
    // Solve TDSE
    ArrayXd dipole = Schrodinger_atom_1D::solve_TDSE_PS(N_it_,
                        std::complex<double> (dt_ / physics.t_at, 0.0), E_ / physics.E_at, 1);
    
    return(dipole);
}


//------------------------------------------------------------------------------------------------//
// TDSE solver (pseudo-spectral method)

ArrayXd Schrodinger_atom_1D::solve_TDSE_PS(int N_it_, std::complex<double> dt_,
                                           ArrayXd E_, int e_) {
    
    maths_textbook maths;
    
    // Operators
    ArrayXcd T = (0.5 * xkx.kx.pow(2)).cast<std::complex<double> >();
    ArrayXcd V = ArrayXcd::Zero(xkx.N_x);
    
    // Initialise wavefunction, output and boundary
    wfn = wfn_GS;
    ArrayXd output = ArrayXd::Zero(N_it_);
    ArrayXcd boundary = (1 - ((0.5 * maths.pi * xkx.x /
                              xkx.x_max).sin()).pow(50)).cast<std::complex<double> >();
    
    // Set up transform, MKL
    MKL_LONG dimension = 1;
    MKL_LONG length = xkx.N_x;
    double scale_factor = 1.0 / xkx.N_x;
    
    DFTI_DESCRIPTOR_HANDLE transform;
    DftiCreateDescriptor(&transform, DFTI_DOUBLE, DFTI_COMPLEX, dimension, length);
    DftiSetValue(transform, DFTI_BACKWARD_SCALE, scale_factor);
    
    DftiCommitDescriptor(transform);
    
    // Main loop
    for (int ii = 0; ii < N_it_; ii++) {
        
        std::cout << ii << std::endl;
        
        // Update operator
        V = (V_model + (xkx.x * E_(ii))).cast<std::complex<double> >();
        
        // Propagate
        DftiComputeForward(transform, wfn.data());
        wfn *= (std::complex<double>(0, -0.5) * T * dt_).exp();
        DftiComputeBackward(transform, wfn.data());
        
        wfn *= (std::complex<double>(0, -1) * V * dt_).exp();
        
        DftiComputeForward(transform, wfn.data());
        wfn *= (std::complex<double>(0, -0.5) * T * dt_).exp();
        DftiComputeBackward(transform, wfn.data());
        
        wfn *= boundary;
        
        // Calculate expectation values
        if (e_ == 0) {
            
            // Energy
            ArrayXcd temp = wfn;
            DftiComputeForward(transform, temp.data());
            temp *= T;
            DftiComputeBackward(transform, temp.data());
            energy = maths.trapz(xkx.x, (wfn.conjugate() * temp).real()) +
                     maths.trapz(xkx.x, (wfn.conjugate() * V * wfn).real());
            output(ii) = energy;
            
            // Re-normalize
            wfn *= std::pow(maths.trapz(xkx.x, wfn.abs2()), -0.5);
            
        } else if (e_ == 1) {
            
            // Displacement
            output(ii) = maths.trapz(xkx.x, (wfn.conjugate() * xkx.x * wfn).real());
            
        } else {
            
            // Spare
            std::cout << "Invalid expectation value!" << std::endl;
            
        }
        
    }
    
    // Clean up
    DftiFreeDescriptor(&transform);
    
    return(output);
}




